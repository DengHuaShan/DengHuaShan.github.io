<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MySQL的性能优化]]></title>
    <url>%2F2017%2F07%2F11%2Fmysql-optimize%2F</url>
    <content type="text"><![CDATA[MySQL的性能优化包括查询速度优化，更新速度优化，MySQL服务器优化等。如果是SQL查询很慢，可以开启MySQL的慢查询日志。通过慢查询日志，可以找出执行时间较长、执行效率较低的语句，然后进行优化。 EXPLAIN分析通过EXPLAIN语句对查询语句进行分析，找出查询语句的执行瓶颈。上一章稍微介绍过EXPLAIN语句，这里再详细阐述一下。基本语法：EXPLAIN SELECT select_options id：SELECT识别符。SELECT的查询序列号。 select_type：SELECT语句的类型。取值说明如下：SIMPLE表示简单查询，不包括连接查询和子查询。PRIMARY表示主查询，或者是最外层的查询语句。UNION表示连接查询的第二个或后面的查询语句。DEPENDENT UNION表示连接查询中的第二个或后面的SELECT语句，取决于外面的查询。UNION RESULT表示连接查询的结果。SUBQUERY表示子查询中的第一个SELECT语句。DERIVED表示导出表的SELECT中的子查询。 table：表示查询的表 type：表示表的连接类型。取值说明如下：（从最佳类型到最差类型排序）system，该表示仅有一行的系统表。const：数据表最多只有一个匹配行，它将在查询开始时被读取。查询速度很快，因为只读取一次。示例SQL： SELECT * FROM tb_name WHERE primary_key=?; SELECT * FROM tb_name WHERE primary_key_part1=? AND primary_key_part2=?; eq_ref：对于每个来自前面的表的行组合，从该表中读取一行。可以用于使用”=”操作符比较带索引的列。示例SQL： SELECT * FROM ref_tb,other_tb WHERE ref_tb.key_column=other_tb.column; SELECT * FROM ref_tb,other_tb WHERE ref_tb.key_column_part1=other_tb.column AND ref_tb.key_column_part2=?; ref：对于来自前面的表的任意行组合，将从该表中读取所有匹配的行。可以用于使用”=”或”&lt;=&gt;”操作符带索引的列。示例SQL： SELECT * FROM ref_tb WHERE key_column=expr; SELECT * FROM ref_tb,other_tb WHERE ref_tb.key_column=other_tb.column; SELECT * FROM ref_tb,other_tb WHERE ref_tb.key_column_part1=other_tb.column AND ref_tb.key_column_part2=?; ref_or_null：如同ref，专门搜索包含NULL值的行。示例SQL： SELECT * FROM ref_tb WHERE key_column=expr OR key_column IS NULL; index_merge：使用了索引合并优化方法。key列中包含了使用的索引清单。unique_subquery：索引查找函数，可以完全替换子查询。可以下面形式的IN子查询value IN(SELECT primary_key FROM tb WHERE some_expr) index_subquery：可以替换IN子查询，只适合下列形式的子查询中的非唯一索引。value IN(SELECT key_column FROM tb WHERE some_expr) range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引。当使用”=”，”&lt;&gt;”，”&gt;”，”&gt;=”，”&lt;”，”&lt;=”，”IS NULL”，”&lt;=&gt;”，”BETWEEN”，”IN”操作符，用常量比较关键字列时，类型为range。index：只扫描索引树。ALL：对于前面的表的任意行组合，进行完整的全表扫描。 possible_keys：能使用哪个索引在该表中找到行。NULL则没有相关的索引。 key：实际查询时使用到的索引。NULL则没有选择所有。 key_len：索引自动按字节计算的长度。数值越小，表示越快。 ref：使用哪个列或常数与索引一起来查询记录。 rows：在表中进行查询时必须检查的行数。 Extra：处理查询时的详细信息。设计合理的索引如下图，没有在f_name字段上增加索引。可以分析执行了全表。查询在f_name字段上增加索引的选择性。选择性越高的索引价值越大。建立索引再来分析。索引未起作用的特殊情况 在使用LIKE关键字的查询语句中，如果匹配字符串的第一个字符为”%”，索引将不会起作用。只有”%”不在第一个位置，索引才会起作用。 使用多列索引，也就是组合索引。遵循最左前缀集合。比如在f_id、f_name、f_price三个字段创建组合索引。那么在查询条件包含f_id、f_name、f_price或f_id、f_name或f_id时会使用到索引。而f_name、f_price条件则索引将不会起作用。 查询语句的查询条件中只有OR关键字，且OR前后的两个条件中的列都是索引时，查询才会使用到索引。子查询说明子查询虽然可以使查询语句很灵活，但执行效率不高。这是因为MySQL在执行子查询时，会为内层查询语句的查询结果建立一张临时表。然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表。建议使用连接查询来替代子查询。连接查询不需要建立临时表。SELECT语句中避免使用*号通配符。数据库在解析的过程中，会将*号依次转换成所有的列名，这个工作是通过查询数据字典完成的。意味着耗费更多的时间。数据库的结构优化对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新的表。范式 范式是为解决数据的存储与优化。保存数据的存储后，凡是能够通过关系寻找出来的数据，坚决不再重复存储，终极目标是为了减少数据的冗余。范式是一种分层结构的规范，分为六层。每一层都比上一层更加严格，若要满足下一层范式，前提是满足上一层范式。 六层范式：1NF、2NF、3NF、4NF、5NF、6NF MySQL属于关系型数据库，有空间上的浪费，其本身也是致力于节省存储空间，与范式所解决的问题不谋而合，在设计数据库的时候，会利用范式来指导设计，但不是强制规范。但是数据库不单是要解决空间问题，还要保证效率问题。范式只为解决空间问题，所以数据库的设计又不能完全按照范式的要求实现。一般情况下，满足3NF即可。 1NF：在设计表存储数据的时候，如果表中设计的字段存储的数据，在取出来使用之前，还需要额外的处理或拆分，那么该表的设计不满足第一范式。第一范式要求字段的数据具有原子性，不可再分。 2NF：在数据表设计的过程中，如果有复合主键（多字段主键），且表中有字段并不是由整个主键来确定，而是依赖主键中的某个字段（主键的部分）。即存在字段依赖主键的部分，称之为部分依赖。第二范式就是要解决表的设计不允许出现部分依赖。 3NF：理论上讲，应该一张表中的所有字段都直接依赖主键（逻辑主键：代表的是业务主键）。如果表设计中存在一个字段，并不直接依赖主键，而是通过某个非主键字段依赖，最终实现依赖主键。把这种不是直接依赖主键，而是依赖非主键字段的依赖关系称之为传递依赖。第三范式就是要解决传递依赖的问题。 逆规范化：在设计表的时候，如果一张表中有几个字段是需要从另外的表中去获取信息，理论上讲，的确可以获取到想要的数据，但是效率低一点。这时，会刻意的在某些表中，不去保存另外表的主键（逻辑主键），而是直接保存想要的数据信息。这样一来，在查询数据时，一张表可以直接提供数据，而不需要多表查询（效率低），但是会导致数据冗余增加。同时还需保证数据的一致性。其他优化MySQL数据库配置优化这里就不说了。工作重点不在这一块，纯属了解了一下。]]></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL中InnoDB存储引擎的索引]]></title>
    <url>%2F2017%2F07%2F10%2Fmysql-index%2F</url>
    <content type="text"><![CDATA[索引是对数据库，表中一列或多列的值进行排序的一种结构，使用索引可提高数据库中特定数据的查询速度。索引是一个单独的、存储在磁盘上的数据库结构，它包含着对数据表中所有记录的引用指针。MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。索引的本质：索引是数据结构。 存储引擎支持的索引 MyISAM、InnoDB只支持BTree索引，Memory、Heap存储引擎可以支持Hash、BTree索引。索引的分类 普通索引：MySQL中的基本索引类型，允许在定义所以的列中插入重复值和空值。 唯一索引：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。主键索引是一种特殊的唯一索引，不允许有空值。 单列索引：一个索引只包含单个列，一个表可以有多个单列索引。 组合索引：在表的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用。使用组合索引时遵循最左前缀集合。 全文索引：在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引可以在CHAR、VARCHAR或TEXT类型的列上创建。只有MyISAM存储引擎支持全文索引。 空间索引：是对空间数据类型的字段建立的索引。创建空间索引的列，不允许有空值。只有MyISAM存储引擎支持空间索引。索引的优点 通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。 可以大大加快数据的查询速度，这也是创建索引的最主要原因。索引的缺点 创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加。 索引需要占用磁盘空间，即物理空间。如果有大量的索引，索引文件可能比数据文件更快达到最大文件尺寸。 当对表中的数据进行增加、删除和修改时，索引也要动态的维护，降低了数据的维护速度。InnoDB存储引擎的索引实现 InnoDB存储引擎使用B+Tree作为索引结构。在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。 InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键。如果没有显示指定主键，InnoDB会为每一行生成一个隐藏的6个字节的ROWID，并以此作为主键。《MySQL的存储引擎》一章所提到的。 在使用InnoDB存储引擎时，如果没有特别的需要，使用一个与业务无关的自增字段作为主键则是一个很好的选择。聚集索引与非聚集索引 聚集索引表记录的排列顺序与索引的排列顺序一致，优点是查询速度快，因为一旦具有第一个索引值的纪录被找到，具有连续索引值的记录也一定物理的紧跟其后。聚集索引的缺点是对表进行修改速度较慢，这是为了保持表中的记录的物理顺序与索引的顺序一致，而把记录插入到数据页的相应位置，必须在数据页中进行数据重排，降低了执行速度。类似于数组。 非聚集索引指定了表中记录的逻辑顺序，但记录的物理顺序和索引的顺序不一致，聚集索引和非聚集索引都采用了B+Tree的结构。非聚集索引比聚集索引层次多，添加记录不会引起数据顺序的重组。类似于链表。聚集索引和非聚集索引的区别 两者的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。 聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个。 聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续。 聚集索引查询数据速度快，插入数据速度慢；非聚集索引反之。索引的设计原则 索引并非越多越好，这里不再阐述原因。 避免对经常更新的表进行过多的索引，索引中的列尽可能少，而对经常用于查询的字段应该创建索引。 数据量小的表最好不要使用索引。查询花费的时间可能比遍历索引的时间还要短。 索引的选择性较低时，不应建立索引。索引的选择性所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：Index Selectivity = Cardinality / #T显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。数据如下图：以dept_no做为建立索引的选择性：SELECT count(DISTINCT(dept_no))/count() AS Selectivity FROM employee;以e_no做为建立索引的选择性：SELECT count(DISTINCT(e_no))/count() AS Selectivity FROM employee;可以对比出，在e_no列上建立索引的选择性更高。当在e_no列上建立索引后，可以使用EXPLAIN语句查看索引是否正在使用。EXPLAIN语句输出结果的各个行解释select_type：指定所使用的SELECT查询类型。table：指定数据库读取的数据表名字，它们按照被读取的先后顺序排列。type：指定了本数据表与其他数据表之间的关联关系。可能的取值有：system、const、eq_ref、ref、range、index、All。possible_keys：在搜索数据记录时可选用的各个索引。key_len：给出索引按字节计算的长度，key_len数值越小，表示越快。ref：给出了关联关系中另一个数据表里的列名称。rows：执行这个查询时预计会从这个数据表中读取的数据行的个数。extra：其他与关联操作有关的信息。]]></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL的存储引擎]]></title>
    <url>%2F2017%2F07%2F06%2Fmysql-store-engine%2F</url>
    <content type="text"><![CDATA[数据库存储引擎是数据库底层软件组件。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能。MySQL的核心就是存储引擎。 查看MySQL支持的引擎类型在MySQL中，不需要在整个服务器中使用同一种存储引擎，针对具体要求，可以对每一个表使用不同的存储引擎。MySQL5.6支持的存储引擎有：InnoDB、MyISAM、Memory、Merge、Archive、Federated、CSV、BLACKHOLE等。可以使用SHOW ENGINES语句查看系统所支持的引擎类型。Support列的值表示某种引擎是否能使用。DEFAULT为默认存储引擎。 InnoDB存储引擎MySQL5.5.5之后，默认的存储引擎。支持事务安全表（ACID），支持行锁定和外键。主要特性有： InnoDB给MySQL提供了具有提交、回滚和崩溃恢复能力的事务安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在SELECT语句中提供一个类似Oracle的非锁定读。在SQL查询中，可以将InnoDB类型的表与其他MySQL的表的类型混合起来。 InnoDB是为处理巨大数据量的最大性能设计。它的CPU效率可能是任何其他基于磁盘的关系数据库引擎所不能匹敌的。 InnoDB存储引擎完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲区。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件。 InnoDB支持外键完整性约束。存储表中的数据时，每张表的存储都是按主键顺序存放，如果没有显示指定主键，InnoDB会为每一行生成一个隐藏的6个字节的ROWID，并以此作为主键。建议InnoDB的主键采用数据库自增策略。后期再补充InnoDB的索引MyISAM存储引擎MyISAM基于ISAM存储引擎，并对其进行扩展。MyISAM拥有较高的插入、查询速度，但不支持事务。在MySQL5.5.5之前的版本中，MyISAM是默认存储引擎。主要特性有： 大文件（达63位文件长度）在支持大文件的文件系统和操作系统上被支持。 当把删除和更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。这要通过合并相邻被删除的块。若下一个块被删除，就扩展下一块来自动完成。 每个MyISAM表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16个。 最大的键长度是1000字节，可以通过编译来改变。对键长度超过250字节的情况，一个超过1024字节的键将被用上。 BLOB和TEXT列可以被索引。 NULL值被允许在索引的列中，这个值占每个键的0~1个字节。 所有数字键值以高字节优先被存储，以允许一个更高地索引压缩。 每个MyISAM类型的表都有一个AUTO_INCREMENT的内部列，当INSERT和UPDATE时，该列被更新同时被刷新。 可以把数据文件和索引文件放在不同目录。 每个字符列可以有不同的字符集。 有VARCHAR的表可以固定或动态记录长度。 VARCHAR和CHAR列可以多达64KB。Memory存储引擎Memory存储引擎将表中的数据，存储到内存中。为查询和引用其他表数据提供快速访问。主要特性有： 每一个表可以有多达32个索引，每个索引16列，以及500字节的最大键长度。 执行哈希（Hash）索引和BTree索引。 在一个Memory表中可以有非唯一键。 使用一个固定的记录长度格式。 不支持BLOB和TEXT列。 支持AUTO_INCREMENT列、可以对包含NULL值的列建立索引。 表内容被存在内存中。 当不在需要表的内容时，要释放被表使用的内存，应该执行DELETE FROM或TRAUNCATE TABLE，或删除整个表（DROP TABLE）。（这里不阐述DELETE、TRAUNCATE、DROP之间的区别）存储引擎的选择更改数据表存储引擎查看数据表存储引擎，使用SHOW CREATE TABLE &lt;表名\G&gt;，语句进查看。（“\G”是参数，使结果更加直观，易于查看）更新数据表存储引擎，使用ALTER TABLE &lt;表名&gt; ENGINE=&lt;存储引擎名&gt;;注意MySQL中外键约束是用来保证数据的参照完整性，如果表之间需要关联外键，却指定了不同的存储引擎，这些表之间是不能创建外键约束的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议详解与回顾]]></title>
    <url>%2F2017%2F07%2F04%2Fhttp-protocol%2F</url>
    <content type="text"><![CDATA[HTTP（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。HTTP请求的有三次握手建立连接，四次挥手断开连接。最终都是为了进行可靠传输服务。这里不做过多说明，如有兴趣，请参阅《TCP/IP详解》三本神书。 HTTP协议的版本：HTTP/1.0、HTTP/1.1版本 HTTP/1.1版本这个版本增加了持久连接，就是说之前版本的协议一次请求就是一次TCP连接，请求完成后这个连接就关闭掉了。众所周知TCP协议是可靠的，建立连接需要3次握手，断开连接需要4次挥手，并且TCP有流量控制和拥塞控制，有慢开始机制，刚建立连接时传输比较慢，这是比较耗费资源的。一个丰富的页面会有许多图片、表单和超链接。这样的话就会有多次的HTTP请求，所以在这个版本上默认不关闭TCP连接也不用声明Connection: keep-alive字段。如果确实要关闭可以指定Connection: close字段。还引入了管道机制，就是说在一个TCP连接里可以同时发送多个HTTP请求，而不必等待上一个请求响应成功再发送。还增加了PUT、PATCH、HEAD、 OPTIONS、DELETE等命令，丰富了客户端和服务端交互动作。还增加了Host字段。 HTTP协议的特点HTTP协议是无状态的就是说每次HTTP请求都是独立的，任何两个请求之间没有什么必然的联系。但是在实际应用当中并不是完全这样的，引入了Cookie和Session机制来关联请求。 多次HTTP请求在客户端请求网页时多数情况下并不是一次请求就能成功的，服务端首先是响应HTML页面，然后浏览器收到响应之后发现HTML页面还引用了其他的资源，例如，CSS，JS文件，图片等等，还会自动发送HTTP请求这些需要的资源。现在的HTTP版本支持管道机制，可以同时请求和响应多个请求，大大提高了效率。 基于TCP协议HTTP协议目的是规定客户端和服务端数据传输的格式和数据交互行为，并不负责数据传输的细节。底层是基于TCP实现的。现在使用的版本当中是默认持久连接的，也就是多次HTTP请求使用一个TCP连接。 代码public class TcpSever { public static void main(String[] args) throws Exception { ServerSocket ss = new ServerSocket(10000); Socket s = ss.accept(); InputStream in = s.getInputStream(); byte[] by = new byte[1024]; int len = in.read(by); System.out.println(new String(by, 0, len)); } } 写一个简单的HTML文件，带一个form表单。 请求头get的请求方式&lt;form action=&quot;http://127.0.0.1:10000&quot; method=&quot;get&quot;&gt; GET /?userName=jiujiu&amp;pass=123&amp;sex=nan&amp;hobby=sports&amp;country=CN&amp;province=GZ&amp;area=GZ&amp;btn1=%CC%E1%BD%BB%B1%ED%B5%A5 HTTP/1.1Accept: text/html, application/xhtml+xml, /Accept-Language: zh-Hans-CN,zh-Hans;q=0.8,en-US;q=0.5,en;q=0.3User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like GeckoAccept-Encoding: gzip, deflateHost: 127.0.0.1:10000DNT: 1Connection: Keep-Alive Get方式的特点：传送的数据量受URL地址栏限制，传输的数据直接拼在URL地址后，以问号开始（?），多参数分隔以与符号开始（&amp;）。直接传输中文会乱码，HTTP头字段只接受ASCII码值数据。jsp中可以通过URLEncoder.encode()转换成ASCII码值。 post的请求方式&lt;form action=&quot;http://127.0.0.1:10000&quot; method=&quot;post&quot;&gt; POST / HTTP/1.1Accept: text/html, application/xhtml+xml, /Accept-Language: zh-Hans-CN,zh-Hans;q=0.8,en-US;q=0.5,en;q=0.3Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like GeckoAccept-Encoding: gzip, deflateHost: 127.0.0.1:10000Content-Length: 105DNT: 1Connection: Keep-AliveCache-Control: no-cache userName=hehe&amp;pass=4321&amp;sex=nan&amp;hobby=sports&amp;country=CN&amp;province=GZ&amp;area=GZ&amp;btn1=%CC%E1%BD%BB%B1%ED%B5%A5Post方式的特点：传送的数据量无限制。传输的数据是放在请求体中。 常用请求头说明请求头与请求体的分隔，是以一个空行隔开的。第一行为请求行，包含请求方式与HTTP协议版本号。Accept: 浏览器所支持的数据类型。Accept-Charset: 浏览器所支持的数据类型。Accept-Encoding: 浏览器支持的压缩格式Accept-Language: 浏览器支持的语言环境Host: 想访问哪台主机If-Modified-Since: 缓存数据的时间。浏览器为了提高性能，一般情况会缓存第一次的请求结果，在缓存数据时间内，会直接找本地缓存数据。Referer: 客户机是从哪个页面来的。作用：服务器可以做判断，进行防盗链。Connection: 请求完后是断开还是保持连接。 响应头下图是一个IE插件，HttpWatch捕捉到的一次请求。左边是请求头，右边是响应头。 常用响应头说明HTTP/1.1 200 OK Server: bfe/1.0.8.18 Date: Wed, 05 Jul 2017 01:49:57 GMT Content-Type: text/html; charset=utf-8 Transfer-Encoding: chunked Connection: keep-alive Vary: Accept-Encoding Cache-Control: private Cxy_all: baidu+63b9ff6074957f7dc4b1c7d31442fcfd Expires: Wed, 05 Jul 2017 01:49:46 GMT X-Powered-By: HPHP X-UA-Compatible: IE=Edge,chrome=1 Strict-Transport-Security: max-age=172800 BDPAGETYPE: 1 BDQID: 0xfafa4d1200006790 BDUSERID: 0 Set-Cookie: BDSVRTM=0; path=/ Set-Cookie: BD_HOME=0; path=/ Set-Cookie: H_PS_PSSID=1425_21115_17001_23632_20929; path=/; domain=.baidu.com Content-Encoding: gzip 第一行为状态行，状态码用于表示服务器对请求的处理结果。Location: 跳转到哪里，通常是跟状态码302一起出现。Server: 告诉浏览器，服务器型号Content-Encoding: 告诉浏览器，数据的压缩格式Content-Length: 告诉浏览器，回送数据的长度Content-Type: 告诉浏览器，回送数据的类型Content-Language: 语言环境Refresh: 告诉浏览器，定时刷新Content-Dispostion: 告诉浏览器以下载方式打开数据Transfer-Encoding: 数据是以分块方式回送的Expires: -1Cache-Control: no-cachePragma: no-cache后面三个都是控制浏览器不要缓存。 常见的状态码100～199：表示成功接收请求，要求客户端继续提交下一次请求才能完成整个处理过程200～299：表示成功接收请求并已完成整个处理过程，常用200（OK）300～399：为完成请求，客户需进一步细化请求。例如，请求的资源已经移动一个新地址，常用302、304（未改动）和307（暂时重定向）400～499：客户端的请求有错误，常用404（找不到资源）500～599：服务器端出现错误，常用500（内部服务器错误） 响应体响应头与响应体之间也是以一个空行分隔的。响应体的数据都是二进制数据，浏览器能解析。 关于HTTP的常见问题及解答GET和POST的区别 从字面意思和HTTP的规范来看，GET用于获取资源信息而POST是用来更新资源信息。 GET提交请求的数据实体会放在URL的后面，用?来分割，参数用&amp;连接，举个栗子：/index.html?name=wang&amp;login=1 GET提交的数据长度是有限制的，因为URL长度有限制，具体的长度限制视浏览器而定。而POST没有。 GET提交的数据不安全，因为参数都会暴露在URL上。408 Request Timeout和504 Gateway Timeout的区别408是说请求超时，就是建立连接之后再约定的时间内客户端没有发送请求到客户端到服务端。本质上原因在于客户端或者网络拥塞。504是网关超时，是说代理服务器把客户端请求转发到应用服务器后再约定的时间内没有收到应用服务器的响应。本质上原因在于服务端的响应过慢，也有可能是网络问题。Cookie和Session的区别和联系Cookie和Session都是为了保存客户端和服务端之间的交互状态，实现机制不同，各有优缺点。首先一个最大的区别就是Cookie是保存在客户端而Session就保存在服务端的。Cookie是客户端请求服务端时服务器会将一些信息以键值对的形式返回给客户端，保存在浏览器中，交互的时候可以加上这些Cookie值。用Cookie就可以方便的做一些缓存。Cookie的缺点是大小和数量都有限制；Cookie是存在客户端的可能被禁用、删除、篡改，是不安全的；Cookie如果很大，每次要请求都要带上，这样就影响了传输效率。Session是基于Cookie来实现的，不同的是Session本身存在于服务端，但是每次传输的时候不会传输数据，只是把代表一个客户端的唯一ID（通常是JSESSIONID）写在客户端的Cookie中，这样每次传输这个ID就可以了。Session的优势就是传输数据量小，比较安全。但是Session也有缺点，就是如果Session不做特殊的处理容易失效、过期、丢失或者Session过多导致服务器内存溢出，并且要实现一个稳定可用安全的分布式Session框架也是有一定复杂度的。在实际使用中就要结合Cookie和Session的优缺点针对不同的问题来设计解决方案。]]></content>
  </entry>
  <entry>
    <title><![CDATA[阻塞队列的实现原理]]></title>
    <url>%2F2017%2F07%2F04%2Fblocking-queue%2F</url>
    <content type="text"><![CDATA[在这里贴一下有界阻塞队列的实现代码，总结一下自己的理解。 代码public class BoundedBuffer { //锁对象 final Lock lock = new ReentrantLock(); final Condition notFull = lock.newCondition(); final Condition notEmpty = lock.newCondition(); //阻塞队列最大容量值为100 final Object[] items = new Object[100]; int putptr, takeptr, count; //缓冲存放对象 public void put(Object x) throws InterruptedException { lock.lock(); try { while (count == items.length) //满了，进行等待 notFull.await(); items[putptr] = x; if (++putptr == items.length) //存放位置的指针要超过容量值了，则回到原点 putptr = 0; ++count; //发信号，让空的走 notEmpty.signal(); } finally { lock.unlock(); } } public Object take() throws InterruptedException { lock.lock(); try { while (count == 0) //空了，进行等待。队列已经取完了。 notEmpty.await(); Object x = items[takeptr]; if (++takeptr == items.length) //取出位置的指针要超过容量值了，则回到原点 takeptr = 0; --count; //发信号，让满的走 notFull.signal(); return x; } finally { lock.unlock(); } } } 结论举一个简单的栗子说明，假设服务器或对外提供的接口并发的最高峰值访问是60，这时突然有80个访问请求需要处理。阻塞队列的应用场景就出现了。主要的作用与目的，就是起到缓冲的作用。存一个，取一个。在代码实现时，判断队列是否已经放满了和判断队列是否已经取空了时用了while，这是一个小小的细节。在等待 Condition 时，允许发生“虚假唤醒”，这通常作为对基础平台语义的让步。]]></content>
  </entry>
  <entry>
    <title><![CDATA[工厂、策略、观察者设计模式]]></title>
    <url>%2F2017%2F07%2F03%2Ffactory-design%2F</url>
    <content type="text"><![CDATA[这里贴一下以前对工厂、策略、观察者设计模式的代码实现。 简单工厂设计模式//此工厂返回service的代理 public class ServiceFactory { private static final ServiceFactory instance = new ServiceFactory(); private ServiceFactory() { } public static ServiceFactory getInstance() { return instance; } //返回具体服务的代理对象 public &lt;T&gt; T createService(String className, Class&lt;T&gt; clazz, final User user) { if (null == className || &quot;&quot;.equals(className.trim()) || null == clazz) { return null; } try { final T t = (T) Class.forName(className).newInstance(); return (T) Proxy.newProxyInstance(ServiceFactory.class .getClassLoader(), t.getClass().getInterfaces(), new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 1.判断用户调用的是什么方法 String methodName = method.getName(); // 2.反射出真实对象上相对应的方法 Method m = t.getClass().getMethod(methodName, method.getParameterTypes()); // 3.看真实对象上相对应的方法是否有权限注解 Permission p = m.getAnnotation(Permission.class); // 4.如果没有,代表访问该方法不需要权限,直接放行 if (p == null) { return method.invoke(t, args); } // 5.如果有,得到该方法需要什么权限, String value = p.value(); Privilege privilege = new Privilege(); privilege.setName(value); // 6.得到用户的权限 if (user == null) { throw new PrivilegeException(&quot;对不起,请先登录!&quot;); } BusinessService service = (BusinessService) t; List&lt;Privilege&gt; list = service .getUserPrivilege(user.getId()); // 7.检查用户是否有权限,如果有权限,放行 if (list.contains(privilege)) { return method.invoke(t, args); } // 8.如果没有权限,则抛编译时异常,提示web层给用户一个友好提示 throw new PrivilegeException( &quot;对不起,您没有相对应的访问权限,请联系管理员!&quot;); } }); } catch (Exception e) { throw new RuntimeException(e); } } } ServiceFactory提供一个创建服务方法。createService()，主要是运用反射产生具体的服务代理对象。代理对象在这里执行方法时，加了一段业务逻辑处理。其实这段代码采用了面向切面的思想（AOP思想），其主要目的实现解耦。获取执行方法上的注解。spring中加在类上的@Service、@Controller、@Component、以及可以加在类上和方法上的@Transactional注解，原理都是类似的。 观察者设计模式在说观察者设计模式之前，需要提一个东西。事件监听：Event事件对象封装了事件源及动作。 事件监听机制 事件监听涉及三个组件：事件源，事件对象，事件监听。 当事件源上发生某一个动作时，它会调用事件监听器的一个方法，并在调用该方法时，把事件对象传递进去。 代码实现//观察者设计模式 public class ObserverDemo { public static void main(String[] args) { Person p = new Person(); System.out.println(&quot;Person对象：&quot; + p); //注册一个监听器 p.registerListen(new PersonListen() { //执行具体事件处理动作 @Override public void doeat(Event e) { Person person = e.getSource(); System.out.println(&quot;监听到事件源：&quot; + person + &quot;，调用eat()方法&quot;); } @Override public void dorun(Event e) { System.out.println(&quot;监听到事件源：调用eat()方法&quot;); } }); p.eat(); p.run(); } } class Person { //事件监听器 private PersonListen personListen; public void eat(){ System.out.println(&quot;Person eat()&quot;); if (personListen != null) { System.out.println(&quot;触发：personListen doeat()&quot;); personListen.doeat(new Event(this)); } } public void run(){ System.out.println(&quot;Person run()&quot;); if (personListen != null) { System.out.println(&quot;触发：personListen dorun()&quot;); personListen.dorun(new Event(this)); } } public void registerListen(PersonListen personListen){ this.personListen = personListen; } } //事件监听接口 interface PersonListen{ public void doeat(Event e); public void dorun(Event e); } //事件对象 class Event{ private Person source; public Event() { } public Event(Person source) { this.source = source; } public Person getSource() { return source; } public void setSource(Person source) { this.source = source; } } 运行结果Java中常用的各种监听都是观察者设计模式。 策略设计模式功能并不清楚对结果的处理方式，对结果的处理由调用者进行传入。而只是把对结果的处理方式做成接口，通过接口来约定双方的行为。 代码//通过接口约定双方的行为 public interface ResultSetHandler { Object handler(ResultSet rs); } //处理对单一对象的封装 public class BeanHandler implements ResultSetHandler { private Class clazz; //用户把Bean传进来 public BeanHandler(Class clazz){ this.clazz = clazz; } @Override public Object handler(ResultSet rs) { try{ if(!rs.next()){ return null; } Object bean = clazz.newInstance(); //获取结果集的元信息 ResultSetMetaData metadata = rs.getMetaData(); //得到结果集中有几列数据 int ColumnCount = metadata.getColumnCount(); for(int i=0;i&lt;ColumnCount;i++){ //得到每列的列名 String ColumnName = metadata.getColumnName(i+1); //通过列名获取每一列的数据 Object ColumnData = rs.getObject(i+1); //反射出类中与列名对应的属性 Field f = clazz.getDeclaredField(ColumnName); f.setAccessible(true); f.set(bean, ColumnData); } return bean; }catch (Exception e) { throw new RuntimeException(e); } } } //处理对List的封装 public class BeanListHandler implements ResultSetHandler { private Class clazz; //用户把Bean传进来 public BeanListHandler(Class clazz){ this.clazz = clazz; } @Override public Object handler(ResultSet rs) { try{ List list = new ArrayList(); while(rs.next()){ Object bean = clazz.newInstance(); ResultSetMetaData metadata = rs.getMetaData(); int count = metadata.getColumnCount(); for(int i=0;i&lt;count;i++){ String name = metadata.getColumnName(i+1); Object value = rs.getObject(name); Field f = bean.getClass().getDeclaredField(name); f.setAccessible(true); f.set(bean, value); } list.add(bean); } return list.size() &gt; 0 ? list:null; }catch (Exception e) { throw new RuntimeException(e); } } } 封装对方法的具体细节处理对查询单一的对象，把具体的处理方式BeanHandler传入。处理对查询一群的对象，把具体的处理方式BeanListHandler传入。上面这段代码是采用JDBC，运用元数据，实现一个简单的OR-Mapping映射类型的DB框架。 Java中的运用 之前有说过TreeSet集合，可以对元素进行排序。但是它本身并不知道，元素该怎么排，而是由调用者，通过实现Comparator接口，把对元素进行排序方式进行传入，TreeSet按照给定的方式进行处理。 mybatis中对于查询的处理，在一级缓存与二级缓存中也是使用策略模式，通过实现ResultHandler接口对查询结果进行处理。]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用动态代理实现一个简单的数据库连接池]]></title>
    <url>%2F2017%2F07%2F02%2Fjdbc-pool%2F</url>
    <content type="text"><![CDATA[明确一点：数据库连接是一个重量级的对象，每一个连接的建立是一个复杂且很消耗资源的事情。为了复用已经创建好的连接，出现了池技术。连接池、线程池、对象池等等。这里采用动态代理实现一个简单的数据库连接池。 代码import java.io.InputStream; import java.io.PrintWriter; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; import java.sql.SQLFeatureNotSupportedException; import java.util.LinkedList; import java.util.Properties; import java.util.logging.Logger; import javax.sql.DataSource; public class JdbcPool implements DataSource { //使用LinkedList集合,会使用到大量的增删改查 private static LinkedList&lt;Connection&gt; list = new LinkedList&lt;Connection&gt;(); static{ try{ //读取数据库连接的必要配置 InputStream in = JdbcPool.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;); Properties prop = new Properties(); prop.load(in); String driver= prop.getProperty(&quot;driver&quot;); String url = prop.getProperty(&quot;url&quot;); String username = prop.getProperty(&quot;username&quot;); String password = prop.getProperty(&quot;password&quot;); //加载驱动 Class.forName(driver); //找数据要多少个链接,就循环多少次 for(int i=0;i&lt;10;i++){ Connection conn = DriverManager.getConnection(url, username, password); //把链接存入集合中 System.out.println(&quot;获取到了链接:&quot;+conn); list.add(conn); } }catch (Exception e) { throw new ExceptionInInitializerError(e); } } /* 1.写一个子类,覆盖close方法 2.写一个Connection的包装类,增强close方法 3.用动态代理,返回一个代理对象出去,拦截close方法的调用,对close方法进行增强 */ public Connection getConnection() throws SQLException { //proxyConnection.commit() proxyConnection.rollback if(list.size()&gt;0){ final Connection conn = list.removeFirst(); //myconnection.commit System.out.println(&quot;池大小是:&quot; + list.size()); //使用动态代理 return (Connection) Proxy.newProxyInstance( JdbcPool.class.getClassLoader(), conn.getClass().getInterfaces(), new InvocationHandler(){ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if(!method.getName().equals(&quot;close&quot;)){ return method.invoke(conn, args); }else{ list.add(conn); System.out.println(conn + &quot;被还给池了！！&quot;); System.out.println(&quot;池大小为&quot; + list.size()); return null; } } }); }else{ throw new RuntimeException(&quot;对不起，数据库忙&quot;); } } @Override public PrintWriter getLogWriter() throws SQLException { // TODO Auto-generated method stub return null; } @Override public void setLogWriter(PrintWriter out) throws SQLException { // TODO Auto-generated method stub } @Override public void setLoginTimeout(int seconds) throws SQLException { // TODO Auto-generated method stub } @Override public int getLoginTimeout() throws SQLException { // TODO Auto-generated method stub return 0; } @Override public Logger getParentLogger() throws SQLFeatureNotSupportedException { // TODO Auto-generated method stub return null; } @Override public &lt;T&gt; T unwrap(Class&lt;T&gt; iface) throws SQLException { // TODO Auto-generated method stub return null; } @Override public boolean isWrapperFor(Class&lt;?&gt; iface) throws SQLException { // TODO Auto-generated method stub return false; } @Override public Connection getConnection(String username, String password) throws SQLException { // TODO Auto-generated method stub return null; } } 原理DataSource接口是必须要实现的，上面那些未实现的方法这里不做说明，都是DataSource接口中需要实现的方法。JdbcPool在加载进内存时候，就已经找数据库获取了10个数据库连接。getConnection()获取数据库连接，返回的就是Connection的一个代理对象出去。最终要做的事情是，拦截对close()方法的处理，当发现调用的是close()方法时，并不去执行释放连接，而是把连接返回到了LinkedList集合里面去了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[装饰、代理设计模式]]></title>
    <url>%2F2017%2F07%2F02%2Fdesign-pattern%2F</url>
    <content type="text"><![CDATA[之前在说单例设计模式的时候提到过，设计模式是针对问题最有效的解决方法。这里再回顾一下自己熟悉的装饰、代理、工厂、策略、观察者设计模式。先说装饰、代理设计模式。 装饰设计模式当想要对已有的对象进行功能增强时，可以定义类，将已有对象传入，基于已有对象的功能，提供加强功能。那么自定义的该类称为装饰类。装饰类。通常会通过构造方法接收被装饰的对象，并基于被装饰对象的功能，提供更强的功能。装饰模式比继承要灵活，避免了继承体系的臃肿。而且降低了类与类之间的关系。装饰类因为只是增强已有对象，具备的功能和已有对象是相同的，只不过提供了更强的功能，所以装饰类和被装饰类通常属于一个体系。 代码//装饰设计模式 public class MyBufferedReader { private Reader r; MyBufferedReader(Reader r) { this.r = r; } public String MyReaderLine() throws IOException { // 定义一个临时容器,原BufferedReader封装的是字符数组 StringBuilder sb = new StringBuilder(); int ch = 0; while ((ch = r.read()) != -1) { if (ch == &apos;\r&apos;) continue; if (ch == &apos;\n&apos;) return sb.toString(); else sb.append((char) ch); } if (sb.length() != 0) return sb.toString(); return null; } public int read(char[] cbuf, int off, int len) throws IOException { return r.read(cbuf, off, len); } public void close() throws IOException { r.close(); } } 增强Reader，增强一个MyReaderLine（读一行）的方法，而其他的方法还是调用原来对象的方法。工作中常用到可能是下图这种情况，有人写了一个工具类方法，但是功能不够强或比较繁琐。那我们不能直接去改这个工具类方法，因为这个工具类方法可能有很多地方进行了调用。要么写个子类进行覆盖，要么进行增强。这也是装饰的一种手法。 当一个Java对象方法不够用的时候，有如下方法解决此问题。 写一个子类，覆盖某个方法。如果父类已经封装了信息，不再建议使用此方法。 写一个此类的包装类，增强某个方法。当包装方式比较复杂时，使用代理模式。 使用代理模式，返回一个代理对象出去，拦截某个方法的调用，并对其进行增强。 代理模式代理模式有点类似明星与经纪人一样。这里主要讲动态代理。某个房地产公司想请某明星代言，直接找该明星的经纪人谈具体的细节，谈好之后，实际的代言是由明星去做。这是一个思路，那我们来看怎么实现。 //代理接口 public interface Subject { String sing(String name); String dance(String name); } //明星 public class Star implements Subject { public String sing(String singName) { System.out.println(&quot;Star sing()，唱&quot; + singName + &quot;歌!&quot;); return &quot;飞吻!&quot;; } public String dance(String danceName) { System.out.println(&quot;Star dance()，跳&quot; + danceName + &quot;舞!&quot;); return &quot;多谢老板!&quot;; } } //明星的经纪人 public class StarProxy { private Subject star = new Star(); public Subject getProxy(){ return (Subject) Proxy.newProxyInstance( StarProxy.class.getClassLoader(), star.getClass().getInterfaces(), new InvocationHandler() { /** * proxy:把代理对象自己传递进来 * method:把代理对象当前调用的方法传递进来 * args:把方法参数传递进来 **/ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 编码指定返回代理对象的干的工作 if(method.getName().equals(&quot;sing&quot;)){ //执行业务逻辑处理 System.out.println(&quot;StarProxy，搞一万块钱来&quot;); return method.invoke(star, args); } if(method.getName().equals(&quot;dance&quot;)){ //执行业务逻辑处理 System.out.println(&quot;StarProxy，搞两万块钱来&quot;); return method.invoke(star, args); } return null; } }); } } public class Test { public static void main(String[] args){ StarProxy proxy = new StarProxy(); Subject s = proxy.getProxy(); System.out.println(s.dance(&quot;拉丁&quot;)); } } 运行如下：Proxy类的newProxyInstance()是JDK自带的动态代理，产生代理对象，基于接口进行代理，拦截对真实对象的访问。代理对象需要具备与真实对象相同的行为，代理对象最终还是找真实对象实现具体的行为。newProxyInstance()方法接收三个参数，第一个是类加载器，第二个是哪个接口，第三个是干什么行为。如果一个类没有接口，要使用动态代理，需要使用CGLib。spring在AOP中两种进行了采用。JDK返回出的代理对象是基于接口生成的。CGLib返回出的代理对象是基于子类生成的，所以类不能被final修饰。]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用ReentrantReadWriteLock实现一个简单的缓存原理]]></title>
    <url>%2F2017%2F07%2F01%2Fcache-system%2F</url>
    <content type="text"><![CDATA[之前说过Lock，ReentrantReadWriteLock是Lock的实现类，可以获取读锁与写锁。这里用ReentrantReadWriteLock做一个简单的缓存系统原理实现。 代码跟注释如下public class CacheSystem { public static void main(String[] args) { CacheUtil cacheUtil = new CacheUtil(); cacheUtil.getObject(&quot;1&quot;); } } class CacheUtil { // 本地存放缓存对象的集合 private Map&lt;String, Object&gt; cacheMap = new HashMap&lt;String, Object&gt;(); // 读写锁 private ReadWriteLock rwl = new ReentrantReadWriteLock(); // 获取数据 public Object getObject(String id) { // 先上读锁 rwl.readLock().lock(); Object object = null; try { object = cacheMap.get(id); if (null == object) { // 发现缓存集合中没有数据，释放读锁 rwl.readLock().unlock(); // 上写锁 rwl.writeLock().lock(); try { if (null == object) { object = &quot;往数据库查询出数据&quot;; cacheMap.put(id, object); } } finally { rwl.writeLock().unlock(); System.out.println(&quot;写锁释放了！&quot;); } // 重新上读锁 System.out.println(&quot;重新上读锁了！&quot;); rwl.readLock().lock(); } } finally { System.out.println(&quot;读锁释放了！&quot;); rwl.readLock().unlock(); } return object; } // 更新数据 public void updateObject(Object obj) { //获取更新对象的ID String id = &quot;1&quot;;//伪代码obj.getId(); Object object = getObject(id); //缓存中有数据，避免数据不一致。清空缓存保存的数据 if(null != object){ cacheMap.remove(id); } System.out.println(&quot;更新数据库中数据&quot;); } } mybatis中的缓存 一级缓存是SqlSession级别的缓存。在操作数据库时需要构造 sqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据。不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。 二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。二级缓存是以namespace来划分的，一个namespace有一个二级缓存。一级缓存工作原理查询时会创建一个唯一的Key。查询缓存Map中是否有对象更新时，执行删除缓存数据一级缓存实现类PerpetualCache类二级缓存需要单独配置，不做过多说明mybatis提供了Cache接口，可对接不同的缓存厂商。如redis、memcached、ehcache。]]></content>
  </entry>
  <entry>
    <title><![CDATA[单例设计模式]]></title>
    <url>%2F2017%2F07%2F01%2Fsingle-design%2F</url>
    <content type="text"><![CDATA[Java中有23种设计模式。设计模式是针对问题最有效的解决方法。单例设计模式：解决一个类在内存中只存在一个对象。 实现步骤 禁止其他的应用程序，通过此类来创建对象。私有化构造函数。 在本类里面创建对象。 为了其他应用程序能够访问本类对象，需要对外界提供一种访问方式。 饿汉式class Single { private static Single s = new Single(); private Single() { } public static Single getInstance() { return s; } } 静态成员，随着类的加载而被加载。该类在加载进内存时候，就已经初始化一个对象。俗称：饿汉式。通过getInstance()即可获取该对象，并使用该对象。 懒汉式class Single { private static Single s = null; private Single() { } public static Single getInstance() { if (s == null) { synchronized (Single.class) { if (s == null) { s = new Single(); } } } return s; } } 静态成员，随着类的加载而被加载。该类在加载进内存时候，对象还不存在。通过getInstance()获取该对象的时候才会初始化。那么这时就会出现线程安全问题。这里需要明确一点：线程安全问题：只读不写没有该问题，有读有写就有该问题。这也是饿汉式为什么没有线程安全问题的原因。 synchronized代码块使用的锁，是该类的字节码对象锁。getInstance()在任何地方调用，都会发生互斥。getInstance()方法用了两个if判断，为什么不直接使用下面的代码呢？public static Single getInstance() { synchronized (Single.class) { s = new Single(); } return s; } 多线程中每一个线程调用getInstance()都会发生互斥。 当有第一个线程进入到同步代码块创建一个对象的时候，刚走到return，互斥已经结束。第二个线程进入到同步代码块，这时又会创建一个对象。在内存中就会出现两个对象。结论加双重if，同步效率较高一点。Java中的示例Runtime类，饿汉式System类，懒汉式]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java中synchronized关键字与JDK1.5中显示Lock操作]]></title>
    <url>%2F2017%2F06%2F30%2Flock%2F</url>
    <content type="text"><![CDATA[本文主要是总结synchronized关键字与JDK1.5中Lock的操作。这里不谈论线程安全问题，线程安全问题是一个比较广而深的问题（volatile关键字、JMM内存模型、线程与主内存和工作内存的交互关系等）。同步使用的前提：1，必须是两个或者两个以上的线程。2，必须是多个线程使用同一个锁。这是才可以称为这些线程被同步了。 synchronized关键字class Resource { public void methodOne(Object obj) { System.out.println(&quot;进入methodOne()，&quot; + obj); synchronized (obj) { System.out .println(System.currentTimeMillis() + &quot;-同步代码块：&quot; + Thread.currentThread().getName() + &quot;，锁=&quot; + obj.toString()); sleep(); } } public synchronized void methodTwo(String str) { System.out.println(&quot;进入methodTwo()，&quot; + str); System.out.println(System.currentTimeMillis() + &quot;-同步方法：&quot; + Thread.currentThread().getName()); sleep(); } public static synchronized void methodThree(String str) { System.out.println(&quot;进入methodThree()，&quot; + str); System.out.println(System.currentTimeMillis() + &quot;-静态同步方法：&quot; + Thread.currentThread().getName()); sleep(); } private static void sleep() { try { Thread.sleep(10000); } catch (InterruptedException e) { e.printStackTrace(); } } } class Thread1 extends Thread { private Resource res; public Thread1(Resource res) { this.res = res; } public void run() { res.methodOne(&quot;lockA&quot;); } } class Thread2 extends Thread { private Resource res; public Thread2(Resource res) { this.res = res; } public void run() { res.methodOne(&quot;lockA&quot;); } } public class TestMain { public static void main(String[] args) { Resource r1 = new Resource(); //Resource r2 = new Resource(); Thread1 t1 = new Thread1(r1); Thread2 t2 = new Thread2(r1); t1.start(); t2.start(); } } 上面一段简单的代码，分别来说明synchronized关键字加在代码片段中、加在方法声明上、加在静态方法声明上，它所使用的锁对象是哪些。 synchronized关键字加在代码片段中Thread1和Thread2使用的是同一个锁对象（lockA）。字符串初始化时存放在方法区的字符串常量池。“lockA”跟new String(“lockA”)，则是两个不同的对象。这里不做过多说明。Thread1和Thread2发生了互斥，说明同步代码块的关键是synchronized关键字括号中的锁对象，可以是任意对象。当锁对象不是同一对象时，synchronized代码块则不会发生互斥。 synchronized关键字加在方法声明上方法需要被对象调用，方法都有一个所属对象的引用，就是this。同步方法使用的锁就是this锁。再来看下面另两幅图。上图中，使用的是不同锁，所以没有发生互斥。当把res对象自己传递给methodOne()时，发现同步代码块跟同步方法开始互斥了。 结论同步方法使用的锁就是this锁。 synchronized关键字加在静态方法声明上再之前的对象初始化过程中提过，静态成员（静态方法与静态属性，专业说话叫类变量）和普通方法也会随着类的加载而被加载。this关键字表示一个对象引用。所以静态同步方法肯定不是用的this锁对象。运行，methodThree()发生了互斥。换种方式。methodOne()采用Resource的字节码对象作为锁对象。与methodThree()发生了互斥。 结论之前说过一个类只有一份字节码文件，在加载进内存时，一个类只有一个字节码文件对象。静态同步方法使用的锁是该方法所在类的字节码文件对象。（类名.class跟对象.getClass()是一码事，都是获取当前类的字节码对象） 死锁 原理：同步中嵌套同步，彼此拿着需要的锁不放。 class Lock implements Runnable{ private boolean flag; Lock(boolean flag){ this.flag=flag; } public void run() { if(flag){ synchronized (Mylock.locka) { System.out.println(&quot;if..locka&quot;); synchronized (Mylock.lockb) { System.out.println(&quot;if..lockb&quot;); } } } else{ synchronized (Mylock.lockb) { System.out.println(&quot;else..lockb&quot;); synchronized (Mylock.locka) { System.out.println(&quot;else..locka&quot;); } } } } } class Mylock{ static Object locka=new Object(); static Object lockb=new Object(); } public class Deadlock { public static void main(String[] args){ Thread t1=new Thread(new Lock(true)); Thread t2=new Thread(new Lock(false)); t1.start(); t2.start(); } } Lock显示锁对象import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; class Resource { private Lock lock = new ReentrantLock(); public void set(String name) { lock.lock(); try { System.out.println(System.currentTimeMillis() + &quot;，&quot; + Thread.currentThread().getName() + &quot;，&quot; + name); try { Thread.sleep(10000); } catch (InterruptedException e) { e.printStackTrace(); } } finally { // 释放锁的操作一定要执行 lock.unlock(); } } } class Producer implements Runnable { private Resource res; public Producer(Resource res) { this.res = res; } public void run() { res.set(&quot;张三&quot;); } } class Consumer implements Runnable { private Resource res; public Consumer(Resource res) { this.res = res; } public void run() { res.set(&quot;李四&quot;); } } public class TestMain { public static void main(String[] args) { Resource r = new Resource(); Producer pro = new Producer(r); Consumer con = new Consumer(r); Thread t1 = new Thread(pro); Thread t2 = new Thread(con); t1.start(); t2.start(); } } 运行一互斥，正常释放锁，正常运行。 运行二互斥，Thread-0未释放锁，Thread-1则一直阻塞。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java的List、Set、Map容器]]></title>
    <url>%2F2017%2F06%2F29%2Flist-set-map%2F</url>
    <content type="text"><![CDATA[数据多了用对象存储，对象多了就用数组或集合存储。使用容器的最基本规则。数组的缺陷在与长度固定，数据类型固定。集合可自动扩容。 为什么会出现这么多的容器呢？因为每一个容器对数据的存储方式都有不同，这个存储方式称之为：数据结构。 List中常用的容器该容器体系存放元素是有序的，元素可以重复。因为该集合体系有索引。List集合判断元素是否相同，依据的是元素的equals()方法。如果需要依据自己的条件进行判断是否为同相同元素，则需要重写equals()方法。 ArrayList 底层使用数组结构。elementData就是该集合存放数据的地方。分配的内存地址空间是连续的一片。 特点：查询速度很快。但是增删稍慢。线程不安全。拿着角标，即可获取到元素。就类似与现实生活中的门牌号。”去找到小明家”，这么多叫小明的，怎么找？”去找到小明家，他住XX街5号”。在角标4的位子插入一个新元素，意味该角标位后面的所有元素都需要挪动一下。假设集合的容量很大，1000、10000、100000或者1000000（当然不能超过int的最大值），就这一个简单的操作，对内存的消耗是非常大的。删除也是同理。 自动扩容，每次都是把原来的数组复制进一个新数组中，新数组的长度增长量是原来的size的50%。看一下ArrayList的源码：自动扩容是发生在添加的时候。容量为当前size+1modCount这里不做详细说明，ConcurrentModificationException异常产生的原因就是因为它。如果size+1减去当前元素数组的长度大于0，则表示需要扩容。第一个红线，新的容量为旧的容量加上旧的容量值右移一位。int数值的二进制右移一位，就是原来数值的一半。所以，扩容的增长量是原来的size的50%。第二个红线，调用Arrays.copyOf()方法。如下图，在原数组的基础上，新增一个数组。LinkedList 底层使用链表结构，双链表。分配的内存地址空间是可以是碎片化空间。 特点：增删很快，查询很慢，线程不安全。增加：让最后一个元素的next记录住当前新增元素的空间地址，并当前新增元素的prev记录上一个元素，last为当前元素地址。删除也是同理，直接让上一个元素的next为null，last为上一个元素地址。上图，get(int index)和remove(int index)方法中，二分原理。ListIteratorList集合特有的迭代器。在迭代时，不可以通过集合对象的方法操作集合中的元素。因为会发生ConcurrentModificationException异常。所以，在迭代器时，只能用迭代器的方式操作元素，可是Iterator方法是有限的，只能对元素进行判断，取出，删除的操作，如果想要其他的操作如添加，修改等，就需要使用其子接口，ListIterator。该接口只能通过List集合的listIterator方法获取。实现简单的队列class MyQueue { private LinkedList&lt;Object&gt; link; MyQueue() { link = new LinkedList&lt;Object&gt;(); } public void myAdd(Object obj) { link.offerFirst(obj); } public Object myGet() { return link.pollLast(); } public boolean isNull() { return link.isEmpty(); } } public class LinkedListTest { public static void main(String[] args) { MyQueue mq = new MyQueue(); mq.myAdd(&quot;java01&quot;); mq.myAdd(&quot;java02&quot;); mq.myAdd(&quot;java03&quot;); mq.myAdd(&quot;java04&quot;); while (!mq.isNull()) { System.out.println(mq.myGet()); } } } Set中常用的容器元素是无序(存入和取出的顺序不一定一致)，元素不可以重复。底层都是使用Map集合存储元素。HashSet 底层数据结构是哈希表，使用HashMap存储元素，只使用了HashMap的Key部分，未使用Value部分。是线程不安全的。 HashSet是如何保证元素唯一性的呢？class Person { private String name; private int age; Person() { } Person1(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public boolean equals(Object obj) { if (!(obj instanceof Person1)) { return false; } Person p = (Person) obj; System.out.println(this.name + &quot;-equals-&quot; + p.name); return this.name.equals(p.name) &amp;&amp; this.age == p.age; } public int hashCode() { // System.out.println(this.name+&quot;...hashCode&quot;); return name.hashCode() + age * 27; //return age * 27; } } public class HashSetTest { public static void main(String[] args) { HashSet&lt;Person&gt; hs = new HashSet&lt;Person&gt;(); hs.add(new Person(&quot;王五&quot;, 21)); hs.add(new Person(&quot;张三&quot;, 22)); hs.add(new Person(&quot;李四&quot;, 19)); hs.add(new Person(&quot;王五&quot;, 22)); for (Iterator&lt;Person&gt; it = hs.iterator(); it.hasNext();) { Person p = it.next(); System.out.println(p.getName() + &quot;，&quot; + p.getAge()); } } } hashCode值采用name.hashCode() + age * 27 hashCode值采用age * 27，age相同就会进行比较，因最终equals不为true，视为不同元素。 hashCode值采用age * 27，age相同就会进行比较，比较了两次，equals为true，视为相同元素，不存入。结论HashSet是通过元素的两个方法，hashCode和equals来完成。如果元素的HashCode值相同，才会判断equals是否为true。如果元素的hashcode值不同，不会调用equals。注意,对于判断元素是否存在，以及删除等操作，依赖的方法是元素的hashcode和equals方法。TreeSet 底层数据结构是二叉树，使用TreeMap存储元素。是线程不安全的。 特点：可以对集合内的元素进行排序。 默认的排序规则是：按自然排序（左小右大）。下图是put方法中的一段代码。 排序重点，比较器或比较接口//如果想让TreeSet拥有其他的排序方式，有两钟方式。 public class TreeSetDemo { public static void main(String[] args) { //TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(); //第二种方式：让集合具备比较性，将比较器对象作为参数传递给TreeSet集合的构造函数 TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(new MyComparator()); ts.add(new Student(&quot;王五&quot;, 21)); ts.add(new Student(&quot;李四&quot;, 20)); ts.add(new Student(&quot;张三&quot;, 23)); ts.add(new Student(&quot;王五&quot;, 21)); ts.add(new Student(&quot;马二&quot;, 19)); ts.add(new Student(&quot;李四&quot;, 19)); for (Iterator&lt;Student&gt; it = ts.iterator(); it.hasNext();) { Student s = it.next(); System.out.println(s.getName() + &quot;，&quot; + s.getAge()); } } } //第一种方式：让Student类实现Comparable接口，重写compareTo方法。强制让学生具备可比性 class Student implements Comparable&lt;Student&gt; { private String name; private int age; Student() { } Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } //重写compareTo()方法，自行定义比较规则 public int compareTo(Student o) { if (this.age &gt; o.age) return 1; if (this.age == o.age) { // 当主要条件满足时，判断次要条件 return this.name.compareTo(o.name); } return -1; } } //自定义比较器，实现Comparator接口 class MyComparator implements Comparator&lt;Student&gt; { public int compare(Student o1, Student o2) { //自行定义比较规则 int num = o1.getName().compareTo(o2.getName()); if (num == 0) // 对象包装类调用compareTo()方法，判断次要条件 return new Integer(o1.getAge()).compareTo(new Integer(o2.getAge())); return num; } } TreeSet保证元素唯一性的依据就是compareTo()方法的return值。大小判断的依据也是该方法的返回值。正数代表大，负数代表小，0则表示是相同元素。//使用匿名内部类的方式，传递比较器 TreeSet&lt;String&gt; ts=new TreeSet&lt;String&gt;(new Comparator&lt;Student&gt;(){ public int compare(Student o1, Student o2) { //自行定义比较规则 int num = o1.getName().compareTo(o2.getName()); if (num == 0) // 对象包装类调用compareTo()方法，判断次要条件 return new Integer(o1.getAge()).compareTo(new Integer(o2.getAge())); return num; } }); Map中常用的容器上面已经说过。Set集合底层就是使用Map集合存储。Map集合被使用是因为具备映射关系。Map集合中，如果键相同，就会出现新值覆盖旧值。Map集合的取值原理：将Map集合转成Set集合，再通过迭代器取出。取值的两种方式： entrySet()：返回值类型为Set]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java对象初始化的过程]]></title>
    <url>%2F2017%2F06%2F29%2Fobjectinit%2F</url>
    <content type="text"><![CDATA[从学Java开始，就一直牢牢的记住着一句话。”基础决定了你在这条道路上能走多远。”，虽然当时不是很明白。但庆幸的是一直都放在心里。再温习一下Java对象初始化的过程，把这种理解性的知识，用图文的方式去描述出来。 一个很简单的Java类public class Student { private String name = &quot;haha&quot;; private int age; private static String country = &quot;cn&quot;; //无参构造函数 Student() { } //有参构造函数 Student(String name, int age) { System.out.println(&quot;有参构造函数：&quot; + name + &quot;..&quot; + age); this.name = name; this.age = age; } //构造代码块 { System.out.println(&quot;构造代码块：&quot; + name + &quot;..&quot; + age); } //静态代码块 static { System.out.println(&quot;静态代码块：static..&quot;); } public void setName(String name) { this.name = name; } public void speak() { System.out.println(this.name + &quot;...&quot; + this.age); } public void listen() { speak(); } public static void showCountry() { System.out.println(&quot;country=&quot; + country); method(); } public static void method() { System.out.println(&quot;method run&quot;); } } Student s = new Student(“zhangsan”, 19);上图中，在我们使用的时候，该句话都做了什么事情？（只谈论内存中的堆、栈区域，不涉及其他区域） 文字结论 当虚拟机读取到这句话的时候，首先看等号的左边。Student s，s是一个变量，虚拟机会在栈内存中开辟空间，存放s这个变量。 当读取到等号的右边new Student(“zhangsan”, 19)。因为用到了Student类，虚拟机会编译Student.java文件，生成Student.class文件。俗称字节码文件，一个类只有一份字节码文件。（请自行区别.java文件跟类的概念） 会把Student这个类的字节码从硬盘加载进内存。这里提一嘴，JVM中的类加载器Classloader。 如果有静态代码块，就会随着类的加载而执行。静态成员（静态方法与静态属性，专业说话叫类变量）和普通方法也会随着类的加载而被加载。 在堆内存中开辟空间，并分配内存地址。（内存地址是十六进制数） 在堆内存中建立对象特有属性，并同时对特有属性进行默认初始化。 对对象属性进行显示初始化。 执行构造代码块，对所有对象进行初始化。 执行对应的构造函数，对对象进行初始化。 将内存地址赋给栈内存中的s变量。（栈内存中的变量指向堆内存中的变量，这就是Java中的指针）静态成员存放在方法区，在内存中只有一份。随着类的的加载而被加载，优先于对象存在，被所有的对象所共享，可以被类名直接调用，也可以被对象调用。showCountry()方法中调用method()，就是直接省略了（Student.）同样的，listen()方法中调用speak()，就是直接省略了（this.）如理解的描述有错，请务必告知。谢谢！对JVM感兴趣的，可以膜拜《深入理解Java虚拟机》一书。]]></content>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客站点解密]]></title>
    <url>%2F2017%2F06%2F26%2Fdecrypt-blog%2F</url>
    <content type="text"><![CDATA[对搭建个人博客站点的步骤进行详细回顾，并记录。个人喜欢图文并茂。总结是检验自己的学习效果，并进行巩固。 系统环境配置 之前说过个人博客采用node.js+hexo+github搭建。要使用hexo，需要在你的系统中支持node.js以及Git，如果还没有，那就需要安装。安装node.js 下载与安装地址：http://www.runoob.com/nodejs/nodejs-install-setup.html 请根据自己操作系统的位数进行下载，这里不在阐述。 检验node.js是否安装好，如下图：安装Git 下载与安装地址：https://git-scm.com/download/ 请根据自己操作系统的位数进行下载，这里不在阐述。 检验Git是否安装好，如下图：安装hexo 安装好Git后，右键点击Git Bash，进入本地Git控制台。$ cd d:/hexo # 可自行安装到任意目录 $ npm install hexo-cli -g # 使用包管理工具npm安装hexo，-g是全局安装 $ hexo init blog # 初始化到blog目录中，可任意选择 $ cd blog # 进入blog目录 $ npm install # 本地安装 $ hexo g # 或者hexo generate，会在当前路径下生成public文件夹 $ hexo s # 或者hexo server，可以在http://localhost:4000/ 查看 这里有必要提下Hexo常用的几个命令：$ hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹 $ hexo server (hexo s) 启动本地web服务，用于博客的预览 $ hexo deploy (hexo d) 部署播客到远端（比如github, heroku等平台） 常用简写$ hexo n == hexo new $ hexo g == hexo generate $ hexo s == hexo server $ hexo d == hexo deploy 现在打开http://localhost:4000/已经可以看到一篇内置的blog了。安装所用的本地环境如下：(可以通过Git控制台输入hexo -v查看)hexo主题设置这里以主题yilia为例进行说明。可以百度搜索hexo主题，有很多。安装主题$ hexo clean $ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 启用主题修改blog目录下的_config.yml配置文件中的theme属性，将其设置为yilia。更新主题$ cd d:/hexo/blog/themes/yilia $ git pull # # 取回远程仓库的变化，并与本地分支合并 $ cd d:/hexo/blog $ hexo g # 生成新的静态文件 $ hexo s # 启动本地web服务器 现在打开http://localhost:4000/，会看已经应用了一个新的主题。GitHub注册GitHub地址：http://www.github.com/注册你的 username 和邮箱，邮箱十分重要，GitHub 上很多通知都是通过邮箱发送。配置和使用 GitHub 登录GitHub，跳过引导页。点击Start a project 入下图示例：以.github.io结尾仓库。红色感叹号，是因为我的仓库已经存在同名项目了。不存在会显示绿色打钩图标 新建的仓库，需要有一次提交记录。红框部分就是一个示例，在Git控制台进行输入。输入之前先让本地 git 项目与远程的 GitHub 建立联系。配置 SSH keys检查 SSH keys的设置$ cd ~/.ssh # 检查本机的ssh密钥 如果提示：No such file or directory，说明你是第一次使用 git。如果有把.ssh文件夹里的文件先删掉。.ssh路径为：’C:\Users\your_user_directory\’，例如我的’C:\Users\DELL\’生成新的 SSH Key：$ ssh-keygen -t rsa -C &quot;邮箱地址@youremail.com&quot; # GitHub注册的邮箱地址，-C为大写的C $ Generating public/private rsa key pair. # 采用非对称加密算法RSA生成公钥与私钥 $ Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa): # 回车就好 $ Enter passphrase (empty for no passphrase): # 加盐处理，输入加密串 $ Enter same passphrase again: # 加盐处理，再次输入加密串 SSH key设置成功界面：添加 SSH Key 到 GitHub 打开本地 id_rsa.pub 文件（参考地址 C:\Users\DELL.ssh\id_rsa.pub）。此文件里面内容为刚才生成的密钥。如果看不到这个文件，你需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。 登陆 GitHub 账号。点击右上角的 Account Settings—&gt;SSH Public keys —&gt; add another public keys 把本地生成的密钥复制到里面（ key 文本框中）， 点击 add key 就ok了使用Git控制台进行第一次提交新建一个文件夹，右键点击Git Bash，进入本地Git控制台。$ echo &quot;# test&quot; &gt;&gt; README.md $ git init $ git add README.md $ git commit -m &quot;first commit&quot; $ git remote add origin https://github.com/denghuashan/denghuashan.git.io.git $ git push -u origin master 此时会要求输入username和password返回GitHub仓库F5刷新一下点击右上角Fork这时，可以通过链接http://denghuashan.github.io/访问了。（现在还没有内容，别着急）部署hexo到Github这是很关键的一步，把在本地web环境下预览到的博客部署到github上，然后就可以直接通过http://denghuashan.github.io/访问了。$ cd d:/hexo/blog $ git clone https://github.com/denghuashan/denghuashan.github.io.git .deploy/denghuashan.github.io 将之前创建的repo克隆到本地，新建一个目录叫做.deploy用于存放克隆的代码。创建一个deploy脚本文件$ hexo generate # 生成最新的静态文件 $ cp -R public/* .deploy/denghuashan.github.io # 拷贝public文件夹下的文件到本地仓库中去 $ cd .deploy/denghuashan.github.io $ git add . # 添加到暂存区 $ git commit -m “update” # 说明为update $ git push origin master # 推送本地分支到远程仓库master分支，输入username和password $ # 在d:/hexo/blog新建一个deploy.sh的文件，保存上面的指令。（shell脚本）下次推送到仓库的时候，直接在Git控制台启用。 $ cd d:/hexo/blog $ sh deploy.sh 再访问http://denghuashan.github.io，就会看到hexo的web页面了。blog目录各文件夹及文件的作用 .deploy：本地仓库 node_modules：nodejs对hexo的支持，不要删除 public：hexo生成的静态文件 source：类似那个webapp目录，该目录下的_posts文件夹就是存放文章的。Markdown文件，方便博客的编写与编辑。 themes：主题文件存放处blog目录下_config.yml文件配置说明# Hexo Configuration ## Docs: https://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site title: DreamMaker-HS # 个人博客的标题。html中head标签中的title subtitle: 勤思善问，可敌良师益友。# 子标题 description: 博学而笃志，切问而静思.! # 描述 author: HuaShan # 作者名 language: timezone: # URL ## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos; url: http://dhsmp.com # 独立域名 root: / permalink: :year/:month/:day/:title/ permalink_defaults: # Directory source_dir: source public_dir: public tag_dir: tags archive_dir: archives category_dir: categories code_dir: downloads/code i18n_dir: :lang skip_render: # Writing new_post_name: :title.md # File name of new posts default_layout: post titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false future: true highlight: enable: true line_number: true auto_detect: false tab_replace: # Category &amp; Tag default_category: uncategorized category_map: tag_map: # Date / Time format ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: YYYY-MM-DD time_format: HH:mm:ss # Pagination ## Set per_page to 0 to disable pagination per_page: 10 pagination_dir: page # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: yilia # 主题，可以更改主题。默认是landscape # Deployment ## Docs: https://hexo.io/docs/deployment.html # 下面的配置需要添加 deploy: # 部署` type:github # 部署类型` repository:https://github.com/denghuashan/denghuashan.github.io.git # 仓库地址` branch:master # 分支` 绑定独立域名$ cd d:/hexo/blog/source/ $ touch CNAME $ vim CNAME # 输入你的域名 $ git add CNAME $ git commit -m &quot;add CNAME&quot; $ sh deploy.sh # 重新生成并提交 我是在阿里云上买的域名，操作基本是一样的。获取GitHub的IP地址，进入source目录下，添加CNAME文件。在域名注册提供商那里配置DNS解析。其他高级技巧 上面已经可以用独立域名进行访问了，其他的一些修改。在themes/(当前使用主题)/_config.yml文件进行修改配置。这里不在阐述。其他的一些特性，在这里只会提到，至于如何使用，请自行摸索。 采用Markdown进行文章的编辑与编写 使用的图床为七牛云存储 + 简易图床。https://portal.qiniu.com/signup?code=3lmipeyx3j782，点这个连接注册，可以给我增加存储空间。谢谢了。 添加404公益页面，推荐使用腾讯公益404。http://www.qq.com/404/ 还可以添加一些其他的插件，如统计访问量、文章字数统计、文章评论与回复、打分，等等。]]></content>
  </entry>
  <entry>
    <title><![CDATA[记住让自己心动时刻]]></title>
    <url>%2F2017%2F06%2F21%2Ffirst-article%2F</url>
    <content type="text"><![CDATA[一直都想建立自己的个人博客站点。只是在近两个月付诸了行动。今天也能算是一个里程碑。顺便记录一下自己的感想，以及对自我的计划。把以前的笔记再总结分享出来。 随想 每天晚上8点到10点，都是自己的学习时间。看书、敲一些跟工作无关的代码。这事，每天都在坚持。不打算放弃它。 一个大目标，我希望在十年后能成为一个软件开发的小牛，让自己能高效而简洁地解决编程问题，但是不受企业低效的管理束缚且有能满足高质量生活的收入水平。 2017年，继续补充并巩固好编程基础理论知识、Java语言核心特性。同时补习自考本科的文化知识。每个月定时的跟踪和调整这个小目标，激励自己前行。 2019年，顺利自考本科通过。满足人生的一大憾事。（人生最痛苦的是，一辈子在后悔中度过） 做一个终身学习者，希望个人博客的文章数能在50岁的时候足够修订成一本散文随记。 个人博客采用node.js+hexo+github搭建的，如有兴趣可以自行百度或发送邮件给我。]]></content>
  </entry>
</search>